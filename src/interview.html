<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  实用技巧：
  <div>
    1.TS NonNullable 可以过滤掉可能为null和undefined的情况，Array[number]取得是数组类型的任意一项类型
      type ISubmitReplay = Array<NonNullable<IModels['POST/wtsy/livecourse/cutReplayVideo.json']['Req']['query']['replayVideoCutList']>[number] & { originUrl?: string }>
  </div>

  <div>
    面试题
    <ul>
      <li>1.Event Loop</li>
        <div>
          js的本质是操作dom，如果两个事件操作了同一个dom就会产生冲突，所以js是单线程的，
          为了处理高优先级的任务，js任务分为了宏任务和微任务，所有的同步任务都在主线程上执行，
          主线程上任务执行完后，去微任务队列中检查微任务是否为空，有就执行，在执行微任务时如果
          碰到了其他微任务，将该微任务放到微任务队列末尾去执行，当微任务队列执行完毕，再去检查
          宏任务队是否为空，有就取出最先进入到队列中的宏任务，执行其同步代码，循环往复。
        </div>
      <li>2.重绘重排&页面渲染过程</li>
        <div>
          1.html被html解析器解析成dom树
          2.css被css解析器解析成cssom树
          3.dom树和cssom树结合生成渲染树
          4.浏览器根据渲染树在屏幕上绘制出渲染树上的所有节点，根据布局flow生成最终页面
        </div>
        <div>
          重绘：元素的样式发生变化，不会影响页面布局
          重排：元素的几何属性发生变化，比如大小，影响了自身及其他元素的排列方式，浏览器需要重新计算排列
          重绘不一定重排，重排一定会重绘
        </div>
      <li>3.React Fiber</li>
        <div>
          state进行更新时，react会重新进行计算，在出现fiber之前，这个计算的过程是不可中断的，如果计算量
          非常大，浏览器就无法响应用户的交互，就会出现卡顿的现象，fiber的出现就是为了让这个计算的过程可中断，
          Fiber可以理解为一个执行单元，比如一个10s的任务，就可以分为10份fiber，当执行完一份之后，再去检查是否
          还有下一份任务，如果有并且当前时间足够执行完下一份任务，就去执行，否则将执行权交回给浏览器优先响应用户
          的交互。
        </div>
      <li>4.React 18新增特性</li>
        <div>
          1.自动批处理：在 React18 之前，只有在 React 事件处理函数中，才会执行自动批处理，其他情况（异步函数、原生js事件）会多次更新；
            在 React18 之后，任何情况都会自动执行批处理，多次更新始终合并为一次
          2.引入新的 root API，React.createRoot(root).render(<App />)，支持并发模式渲染(因为 js 是单线程的，所以当 React 执行
            某些操作时，会阻塞其他进程，例如 UI 渲染，并发模式允许 React 调度程序选取更紧急的任务执行，保持平滑的响应用户需求，避免卡顿)
          3.flushSync 可以关闭批处理
          4.React 组件允许返回 null 或 undefined，18之前只允许返回 Null
        </div>
      <li>5.Redux工作流程</li>
        <div>
          Redux有几个核心模块：
            1.Store：是一个容器保存数据的地方，整个应用只能有一个store
            2.State：store对象包含所有数据，如果想得到某个时点的数据，就要对store生成快照，这种时点的数据集合叫做state，state是只读的
            3.Action：state的变化会导致view的变化，用户接触不到state，只能接触到view，所以state的变化必须是由view导致的，action就是
              view发出的通知，表示state应该要发生变化了
            4.Reducer：store收到action后，必须给出一个新的state，这样view才会发生变化，这种state的计算过程就叫做reducer。reducer是
              一个纯函数，它接收action和当前state为参数，返回一个新的state
            5.dispatch：是view发出Action的唯一方法
          流程：
            1.用户在view通过dispatch发出action
            2.store自动调用reducer并传入action和当前state为参数，reducer返回新的state
            3.state一旦有变化，store就会调用监听函数，来更新view
        </div>
      <li>6.react hook为什么不能放到条件判断中</li>
        <div>
          react是通过单链表来管理hooks的，按hooks的执行顺序依次将hooks节点添加到链表中，每个hook都有两个定义，mount阶段和update阶段，
          mount阶段是初始化状态，update阶段会依次执行update链表中的所有更新操作，最终拿到新的state返回，如果我们将hook放在条件判断中，
          mount阶段初始化了abc三个状态，但是b因为不满足条件在update阶段没有执行，那么就会出现链表取值偏移问题，react就会报错。
        </div>
      <li>7.url输入到浏览器到页面渲染的过程</li>
        <div>
          1.dns解析url获取其ip地址
          2.进行三次握手建立tcp链接，第一次握手客户端向服务端发送一个包，服务端接收到后确认客户端的发送能力和自
          己的接收能力正常；第二次握手服务端向客户端发送一个包，客户端接收到后确认自己的发送接收能力和服务端的发
          送接收能力正常；第三次握手客户端向服务端发送一个包，服务端接收到后确认客户端的接受能力和自己的发送能力
          正常
          3.发起http请求
          4.服务端处理请求并返回相应数据，html、js、css文件就在这里面
          5.客户端根据返回数据进行页面渲染
          6.四次挥手断开连接
        </div>
      <li>8.DNS解析过程</li>
        <div>
          1.浏览器输入url后，操作系统会先检查本地的host文件是否有该url的映射关系，有的话使用该ip地址映射
          2.没有的话客户端会向本地DNS服务器发起查询，如果在本地配置区域资源中，就返回
          3.如果都不存在，则递归的查询根域名服务器、一级域名服务器、二级域名服务器，直至查询到对应的ip地址
        </div>
      <li>9.http1.x问题及2.0优化</li>
        <div>
          http1.x问题：
          1.队头阻塞问题：Chrome 有个机制，对于同一域名，默认允许同时建立6个tcp链接，但同时只能处理一个请求，在
          当前的请求没有结束时，其余的请求都会处于阻塞状态。
          2.无状态导致http头部冗余：无状态导致每一个链接都是新链接，导致每一次请求都会在header中带上cookie等大量
          的身份信息，header里携带的内容过大，在一定程度上增加了传输的成本，并且这些身份信息都是重复的。
          3.明文传输导致不安全
          http2优化：
          1.多路复用：多路复用很好的解决了浏览器限制同一域名下的请求数量问题，同域名下的所有请求都在单个链接上完成，
          这样整个页面资源的下载过程只需要一次慢启动
          2.header压缩：使用http专门的头部压缩算法hpack算法，就是客户端和服务端各自维护一份索引表，用索引号表示
          重复的字符串，来实现头部压缩
        </div>
      <li>10.babel编译流程</li>
        <div>
          1.parse: 通过parse将目标代码转化为ast抽象语法书
          2.transform: 调用ast插件对ast进行增删改
          3.generate: 根据修改后的ast生成最终的目标代码
        </div>
      <li>11.什么是纯函数</li>
        <div>
          纯函数：固定的输入只有唯一的输出，并且不会产生副作用。
          副作用：函数在完成指定任务时同时读取并使用了外部数据尤其是对外部数据进行了修改，导致系统环境发生变化
        </div>
      <li>12.git hook</li>
        <div>
          执行git操作时的事件节点，pre-commit、commit-msg、pre-push
          hask就是封装了git hook
        </div>
      <li>13.fetch ajax axios 关系</li>
        <div>
          ajax是异步请求的统称，不代指某一项技术，axios和fetch都是基于promise封装的ajax请求工具，只不过fetch是
          原生的，axios是封装的xhr的第三方库
        </div>
      <li>14.webpack 打包流程</li>
        <div>
          1.读取入口文件
          2.根据入口文件递归读取依赖的内容
          3.根据依赖关系生成浏览器能够执行的最终代码
          loader: loader是一个函数，这个函数会在我们解析一些文件时执行
          plugin: plugin是对webpack功能的扩充，会在webpack打包的某一节点做一些操作
        </div>
      <li>15.TCP UDP 理解</li>
        <div>
          1.tcp是基于链接的协议，通信前必须建立可靠的链接；udp是无连接协议
          2.tcp提供交付保证，传输过程丢失将会重发；udp传输过程可能会丢包
          3.tcp提供顺序保证，即使到达客户端顺序不一致，tcp也会进行排序；udp不提供有序性保证
          4.tcp速度慢；udp速度快，udp用于直播在线通话
        </div>
      <li>16.软件设计理解</li>
        <div>
          1.可读性：软件设计文档通俗易懂，便于他人理解
          2.可维护性：设计便于维护
          3.可复用性：设计的组件可以在软件其他地方或其他项目中复用
          4.可扩展性：通过添加功能可以实现其他需求
          所有的软件设计都是为了提高研发效率和降低维护成本为目的的
        </div>
      <li>17.设计模式</li>
        <div>
          1.建造者模式：一个复杂的对象可以拆分为多个简单的组件，最后构成该复杂对象
          2.工厂模式：方便处理类似的需求
          3.发布订阅/观察者模式：多个观察者监听一个目标对象，该目标对象发生变化后通知观察者列表自动更新
        </div>
      <li>18.JSON.parse(JSON.stringify())深拷贝有什么问题</li>
        <div>
          1.被拷贝对象如果有时间对象，会被转化为字符串
          2.~如果有正则或者error会被转化为空对象
          3.~如果有函数或undefined会被忽略
          4.~如果有NaN或infinity会被转化为null
          5.~如果存在循环引用将不会被拷贝
        </div>
      <li>19.观察者和发布订阅区别</li>
        <div>
          观察者模式：观察者模式有两个主体，目标对象和观察者，他们是一对多的关系，当目标对象发生变化后，
          会通知观察者列表调用 upload 方法更新，实现自己的业务逻辑
          发布订阅：发布订阅模式有发布者、订阅者、第三方组件信息中介，发布者和订阅者并不会直接通信，需要
          通过信息中介去处理信息交流，所以在发布订阅模式中，组件是松散耦合的
        </div>
      <li>20.什么是闭包？闭包的作用？闭包的注意点？</li>
        <div>
          定义：函数定义和函数表达式位于另一个函数的函数体内，并且这些内部函数可以
          访问他们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。
          当其中一个这样的内部函数在他们所在的外部函数之外被调用时，就会形成闭包。
          作用：可以读取函数内部的变量，并让这些变量的值始终保存在内存中，延长变量的生命周期
          注意点：由于闭包会使得函数中的变量都保存在内存中，内存消耗很大，所以不能滥用闭包，
          否则会造成网页的性能问题。在退出函数之前，将不使用的局部变量全部删除
        </div>
      <li>21.前端性能优化</li>
        <div>
          1.缓存：浏览器缓存和http缓存
          2.cdn加载静态资源
          3.代码压缩&懒加载
          4.精灵图
          5.css新属性：
            content-visibility: auto;
            contain-intrinsic-size: 200px;
            content-visibility: auto; 属性页面加载时，只加载可视区域内容，不是可视区域内容会被跳过渲染，但是会有高度问题，
            使用 contain-intrinsic-size: 200px; 属性解决高度加载问题。
        </div>
      <li>22.npm run dev 时做了什么</li>
        <div>
          1.首先会去项目中的 package.json 文件中找 script 对应的 dev，然后
          执行 dev 的命令
          2.为什么不直接执行 dev 的命令呢？因为这条指令不存在操作系统中，直接执行
          会报错。
          3.那为什么执行 dev 不报错呢？npm install 安装依赖时，会在 node_modules/.bin
          目录中创建好可执行脚本；.bin 目录不是任何一个 npm 包，目录下的文件表示一个个软链接，
          所以当执行 npm run dev 时执行其对应命令就会到 .bin 目录下找到对应脚本来执行。
          4.软链是怎么来的呢？npm install 时，npm 就帮我们把这种软链接配置好了，其实这种软链接
          就相当于一种映射，执行 package.json 命令时，就到 .bin 找映射文件，然后执行对应脚本。
        </div>
      <li>23.cookie、sessionStorage、localStorage区别</li>
        <div>
          共同点：都存储在浏览器本地
          不同点：
            1.cookie 是由服务端写入，而 sessionStorage 和 localStorage 都是由客户端写入
            2.cookie 的生命周期在服务端写入的时候就设置好了；localStorage 除非手动清除，否则一直存在；sessionStorage
            在页面关闭就会自动清除
            3.cookie 的存储空间只有 4KB，localStorage 和 sessionStorage 大概 5MB
            4.cookie 一般用于存储登录验证信息；localStorage 用于存储不易变动的信息，减轻服务端压力；sessionStorage 可以
            检测用户是否刷新进入页面
        </div>
      <li>24.commonJS和ESModule区别</li>
        <div>
          1.commonJS是同步加载模块，ESM是异步加载模块
          2.commonJS输出的是一个值拷贝，即模块内部变化不会影响外部，ESM输出的是只读值引用
          3.commonJS是运行时加载，ESM是编译时输出接口
            commonJS加载的是一个对象，即module.export属性，该对象只有在脚本运行完才会生成
            ESM不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成
          4.commonJs不会提升require，ESModule在编译期间会将所有import提升到顶部
        </div>
      <li>25.为什么虚拟Dom可以提高性能</li>
        <div>
          如果JS代码频繁的操作DOM，不使用虚拟DOM，JS引擎会与DOM引擎频繁切换，重新计算布局绘制图像会引起更大的性能消耗
          1.虚拟DOM不会立马进行排版与重绘操作
          2.虚拟DOM会通过dom diff算法减少不必要的DOM操作，减少过多DOM节点排版重绘损耗
        </div>
      <li>26.什么是DOM Diff算法</li>
        <div>
          DOM Diff算法会先将新旧虚拟DOM树进行逐层比较，并记录下差异，然后根据这些差异去更新DOM节点，最终得到与新虚拟DOM树
          相匹配的真实DOM树。
        </div>
      <li>27.Promise 是什么以及常用的方法</li>
        <div>
          Promise 是用来创建promise对象的构造函数，一个promise对象用来表示一个异步操作的最终状态，以及该异步操作的结果值，
          这个结果值在promise对象创建时是未知的，它允许你为异步操作的成功和失败分别绑定相应的处理回调函数，让异步方法可以像同
          步方法那样被返回。
          常用方法：
          1.finally 无论成功失败都会执行的回调
          2.all 接收一个promise数组，所有promise都成功才会执行成功回调，有一个失败就抛出第一个错误信息
          3.any 接收promise数组，有一个执行通过，则认为成功，否则失败
          4.race 接收promise数组，返回第一个执行完毕的promise对象的结果，无论成功或失败
        </div>
      <li>28.http状态码</li>
        <div>
          200: 成功
          301: 永久重定向
          302: 暂时重定向
          304: 使用缓存资源
          401: 身份验证不通过
          403: 无权限
          404: 资源不存在
          500: 服务器错误，语法或配置错误
          502: 网关或代理服务器接收上游响应是无效的
          503: 服务器停机，没有处于接收状态
          504: 服务器响应超时
        </div>
      <li>29.数组、对象常用方法</li>
        <div>
          数组：
            filter、map、some、every、forEach等等，主要答出 reduce
            reduce: 为数组提供累加器，array.reduce(function(total, currentValue), initialValue)
              total: 初始值或上一次回调返回的值
              currenValue: 数组当前元素值
              initialValue: 初始值
              1.如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中
                的第一个值；
              2.如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，
                那么将抛出 TypeError。
              3.如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值
                将被返回。
          对象：
            Object.keys() 返回键组成的数组
            Object.entries() 返回对象自身键值对组成的二维数组[[key1, value1], [key2, value2]]
            Object.assign() 合并多个对象
            Object.defineProperty(obj, props, description) 实现双向绑定，对标Proxy
              obj: 目标对象
              props: 修改或新增的属性
              description: 对该属性的描述
                value: 需要设置的value值
                writable: 该属性是否可被修改
                enumerable: 该属性是否可枚举
                get: 获取该属性时回调
                set: 修改该属性时回调
                configurable: 是否可以更改除了value和writable之外的其他属性
        </div>
      <li>30.for in 和 for of 区别</li>
        <div>
          1.for in可以遍历数组或对象；for of不能遍历对象
          2.for in遍历数组获取其下标；for of遍历数组获取其值
          3.for in遍历对象获取其key
        </div>
      <li>31.计算机7层模型</li>
        <div>
          应用层（http、ftp等）
          表示层
          会话层
          传输层
          网络层
          数据链路层
          物理层
        </div>
      <li>32.ts常用的内置工具类型</li>
        <div>
          1.Omit: 剔除已定义对象中不需要的一部分形成新的类型。type NewObj = Omit<Obj, "obj属性1", ""obj属性2">
          2.Pick: 选择已定义对象中自己需要的一部分形成新的类型。type NewObj = Pick<Obj, "obj属性1", ""obj属性2">
          3.Partial: 把定义好的对象属性全部转化为可选项。
          4.Required: 与Pratial相反，将已定义好的对象属性变为必选。
          5.Readonly: 把已定义好的对象属性变为只读。
          6.Exclude: 排除两个类型中相同的属性，留下不同的属性。
          7.Extract: 与Exclude相反，排除不同的，留下相同的。
          8.Record: Record<K,T> 构造具有给定类型T的一组属性K的类型（定义对象类型）。
        </div>
      <li>33.ts interface和type的区别</li>
        <div>
          1.type可以用来定义基本类型、对象类型、数组类型、函数类型等；interface只可以定义对象类型和函数类型
          2.type不能重复声明；interface可以重复声明，ts会默认进行声明合并
        </div>
      <li>34.js如何开启多线程</li>
        <div>
          Web Work是h5提供的js解决多线程的方案，将一些大量计算任务放到Web Worker运行而不冻结用户界面。
          语法：new Worker()
        </div>
      <li>35.vite为什么比webpack快</li>
        <div>
          1.服务器启动：vite一开始将应用中的模块区分为依赖和源码两类。
            依赖大多为开发时不会变动的js，vite使用esuild预构建依赖，esbuild使用go编写，预构建依赖比js编写的打包器快10-100倍。
            源码通常包含一些需要被转换的非js文件，并不是所有源码都需要同时被加载，vite以ESM方式提供源码，让浏览器接管了打包程序的部分工作，
            vite只需要在浏览器请求源码时进行转换并按需提供源码。
          2.热更新：
            在vite中，HMR使用ESM动态导入，当编辑一个文件时，vite只需要精确的编译所需的模块，而不是像webpack一样重新编译整个应用程序。
            vite利用http头来加速整个页面重新加载，源码模块会使用304进行协商缓存；依赖模块会通过cache-control: max-age进行强缓存。
        </div> 
      <li>36.什么是慢启动</li>
        <div>
          慢启动是一种拥塞速率算法，用于在TCP/IP网络中调节数据包的发送速率，慢启动算法会在一开始时将传输速率设置为一个较低的值，
          然后逐渐增加，直到网络拥塞或达到最大带宽，这时慢启动又会逐渐降低发送速率，避免网络阻塞丢包，慢启动算法可以让发送方逐渐
          适应实际网络情况，在不丢包的前提下，最大速率的传输数据。
        </div>
    </ul>
  </div>
</body>
<!-- 手写题 -->
<script>
  // 防抖
  function debounce(fn, wait = 50) {
    let timer = null
    return function() {
      if (timer) clearTimeout(timer)
      timer = setTimeout(() => {
        fn && fn()
      }, wait)
    }
  }
  // 节流
  function throttle(fn, gapTime = 50) {
    let lastTime = null
    return function() {
      let currentTime = + new Date()
      if ((currentTime - lastTime) > gapTime || !lastTime) {
        fn && fn()
        lastTime = currentTime
      }
    }
  }
  // 冒泡排序
  function bubleSort(arr) {
    let len = arr.length
    // 外层循环i控制比较的轮数
    for (let i=0; i<len; i++) {
      // 里层循环控制每一轮比较的次数j，arr[i] 只用跟其余的len - i个元素比较
      for (let j=1; j<len-i; j++) {
        // 若前一个元素"大于"后一个元素，则两者交换位置
        if (arr[j-1] > arr[j]) {
          [arr[j-1], arr[j]] = [arr[j], arr[j-1]]
        }
      }
    }
    return arr
  }
  // 插入排序
  function insertSort(arr) {
    let len = arr.length
    for (let i=1; i<len; i++) {
      for(let j=i; j>0; j--) {
        if (arr[j] < arr[j-1]) {
          [arr[j-1], arr[j]] = [arr[j], arr[j-1]]
        }
      }
    }
    return arr
  }
  // 快速排序
  function quickSort(arr) {
    // 结束递归（当ary小于等于一项，则不用处理）
    if (arr.length <= 1) {
      return arr
    }
    // 找到数组的中间项，在原有的数组中把它移除
    let middleIndex = Math.floor(arr.length / 2)
    let middleValue = arr.splice(middleIndex, 1)[0]
    // 准备左右两个数组，循环剩下数组中的每一项，比当前项小的放到左边数组中，反之放到右边数组中
    let leftArr = []
    let rightArr = []
    for (let i=0; i<arr.length; i++) {
      if (arr[i] < middleValue) {
        leftArr.push(arr[i])
      } else {
        rightArr.push(arr[i])
      }
    }
    // 递归方式让左右两边的数组持续这样处理，一直到左右两边都排好序为止。
    //（最后让左边+中间+右边拼接成最后的结果）
    return quickSort(leftArr).concat(middleValue, quickSort(rightArr))
  }
  // 深克隆
  function deepCopy(data, map = new WeakMap()) {
    if (typeof data === 'object') {
      let newData = data instanceof Array ? [] : {}
      if (map.get(data)) {
        return map.get(data)
      }
      map.set(data, newData)
      for (let i in data) {
        if (data[i] instanceof Object || data[i] instanceof Array) {
          newData[i] = deepCopy(data[i], map)
        } else {
          newData[i] = data[i]
        }
      }
      return newData
    } else {
      return data
    }
  }
</script>
</html>