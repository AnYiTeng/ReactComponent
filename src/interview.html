<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div>
    <ul>
      <li>1.Event Loop</li>
        <div>
          js的本质是操作dom，如果两个事件操作了同一个dom就会产生冲突，所以js是单线程的，
          为了处理高优先级的任务，js任务分为了宏任务和微任务，所有的同步任务都在主线程上执行，
          主线程上任务执行完后，去微任务队列中检查微任务是否为空，有就执行，在执行微任务时如果
          碰到了其他微任务，将该微任务放到微任务队列末尾去执行，当微任务队列执行完毕，再去检查
          宏任务队是否为空，有就取出最先进入到队列中的宏任务，执行其同步代码，循环往复。
        </div>
      <li>2.重绘重排&页面渲染过程</li>
        <div>
          1.html被html解析器解析成dom树
          2.css被css解析器解析成cssom树
          3.dom树和cssom树结合生成渲染树
          4.浏览器根据渲染树在屏幕上绘制出渲染树上的所有节点，根据布局flow生成最终页面
        </div>
        <div>
          重绘：元素的样式发生变化，不会影响页面布局
          重排：元素的几何属性发生变化，比如大小，影响了自身及其他元素的排列方式，浏览器需要重新计算排列
          重绘不一定重排，重排一定会重绘
        </div>
      <li>3.React Fiber</li>
        <div>
          state进行更新时，react会重新进行计算，在出现fiber之前，这个计算的过程是不可中断的，如果计算量
          非常大，浏览器就无法响应用户的交互，就会出现卡顿的现象，fiber的出现就是为了让这个计算的过程可中断，
          Fiber可以理解为一个执行单元，比如一个10s的任务，就可以分为10份fiber，当执行完一份之后，再去检查是否
          还有下一份任务，如果有并且当前时间足够执行完下一份任务，就去执行，否则将执行权交回给浏览器优先响应用户
          的交互。
        </div>
      <li>4.React 18新增特性</li>
        <div>
          1.自动批处理：在 React18 之前，只有在 React 事件处理函数中，才会执行自动批处理，其他情况（异步函数、原生js事件）会多次更新；
            在 React18 之后，任何情况都会自动执行批处理，多次更新始终合并为一次
          2.引入新的 root API，React.createRoot(root).render(<App />)，支持并发模式渲染(因为 js 是单线程的，所以当 React 执行
            某些操作时，会阻塞其他进程，例如 UI 渲染，并发模式允许 React 调度程序选取更紧急的任务执行，保持平滑的响应用户需求，避免卡顿)
          3.flushSync 可以关闭批处理
          4.React 组件允许返回 null 或 undefined，18之前只允许返回 Null
        </div>
      <li>5.url输入到浏览器到页面渲染的过程</li>
        <div>
          1.dns解析url获取其ip地址
          2.进行三次握手建立tcp链接，第一次握手客户端向服务端发送一个包，服务端接收到后确认客户端的发送能力和自
          己的接收能力正常；第二次握手服务端向客户端发送一个包，客户端接收到后确认自己的发送接收能力和服务端的发
          送接收能力正常；第三次握手客户端向服务端发送一个包，服务端接收到后确认客户端的接受能力和自己的发送能力
          正常
          3.发起http请求
          4.服务端处理请求并返回相应数据，html、js、css文件就在这里面
          5.客户端根据返回数据进行页面渲染
          6.四次挥手断开连接
        </div>
      <li>6.http1.x问题及2.0优化</li>
        <div>
          http1.x问题：
          1.队头阻塞问题：Chrome 有个机制，对于同一域名，默认允许同时建立6个tcp链接，但同时只能处理一个请求，在
          当前的请求没有结束时，其余的请求都会处于阻塞状态。
          2.无状态导致http头部冗余：无状态导致每一个链接都是新链接，导致每一次请求都会在header中带上cookie等大量
          的身份信息，header里携带的内容过大，在一定程度上增加了传输的成本，并且这些身份信息都是重复的。
          3.明文传输导致不安全
          http2优化：
          1.多路复用：多路复用很好的解决了浏览器限制同一域名下的请求数量问题，同域名下的所有请求都在单个链接上完成，
          这样整个页面资源的下载过程只需要一次慢启动
          2.header压缩：使用http专门的头部压缩算法hpack算法，就是客户端和服务端各自维护一份索引表，用索引号表示
          重复的字符串，来实现头部压缩
        </div>
      <li>7.babel编译流程</li>
        <div>
          1.parse: 通过parse将目标代码转化为ast抽象语法书
          2.transform: 调用ast插件对ast进行增删改
          3.generate: 根据修改后的ast生成最终的目标代码
        </div>
      <li>8.什么是纯函数</li>
        <div>
          纯函数：固定的输入只有唯一的输出，并且不会产生副作用。
          副作用：函数在完成指定任务时同时读取并使用了外部数据尤其是对外部数据进行了修改，导致系统环境发生变化
        </div>
      <li>9.git hook</li>
        <div>
          执行git操作时的事件节点，pre-commit、commit-msg、pre-push
          hask就是封装了git hook
        </div>
      <li>10.fetch ajax axios 关系</li>
        <div>
          ajax是异步请求的统称，不代指某一项技术，axios和fetch都是基于promise封装的ajax请求工具，只不过fetch是
          原生的，axios是封装的xhr的第三方库
        </div>
      <li>11.webpack 打包流程</li>
        <div>
          1.读取入口文件
          2.根据入口文件递归读取依赖的内容
          3.根据依赖关系生成浏览器能够执行的最终代码
          loader: loader是一个函数，这个函数会在我们解析一些文件时执行
          plugin: plugin是对webpack功能的扩充，会在webpack打包的某一节点做一些操作
        </div>
      <li>12.TCP UDP 理解</li>
        <div>
          1.tcp是基于链接的协议，通信前必须建立可靠的链接；udp是无连接协议
          2.tcp提供交付保证，传输过程丢失将会重发；udp传输过程可能会丢包
          3.tcp提供顺序保证，即使到达客户端顺序不一致，tcp也会进行排序；udp不提供有序性保证
          4.tcp速度慢；udp速度快，udp用于直播在线通话
        </div>
      <li>13.软件设计理解</li>
        <div>
          1.可读性：软件设计文档通俗易懂，便于他人理解
          2.可维护性：设计便于维护
          3.可复用性：设计的组件可以在软件其他地方或其他项目中复用
          4.可扩展性：通过添加功能可以实现其他需求
          所有的软件设计都是为了提高研发效率和降低维护成本为目的的
        </div>
      <li>14.设计模式</li>
        <div>
          1.建造者模式：一个复杂的对象可以拆分为多个简单的组件，最后构成该复杂对象
          2.工厂模式：方便处理类似的需求
          3.发布订阅/观察者模式：多个观察者监听一个目标对象，该目标对象发生变化后通知观察者列表自动更新
        </div>
      <li>15.JSON.parse(JSON.stringify())深拷贝有什么问题</li>
        <div>
          1.被拷贝对象如果有时间对象，会被转化为字符串
          2.~如果有正则或者error会被转化为空对象
          3.~如果有函数或undefined会被忽略
          4.~如果有NaN或infinity会被转化为null
          5.~如果存在循环引用将不会被拷贝
        </div>
      <li>16.观察者和发布订阅区别</li>
        <div>
          观察者模式：观察者模式有两个主体，目标对象和观察者，他们是一对多的关系，当目标对象发生变化后，
          会通知观察者列表调用 upload 方法更新，实现自己的业务逻辑
          发布订阅：发布订阅模式有发布者、订阅者、第三方组件信息中介，发布者和订阅者并不会直接通信，需要
          通过信息中介去处理信息交流，所以在发布订阅模式中，组件是松散耦合的
        </div>
      <li>17.什么是闭包？闭包的作用？闭包的注意点？</li>
        <div>
          定义：函数定义和函数表达式位于另一个函数的函数体内，并且这些内部函数可以
          访问他们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。
          当其中一个这样的内部函数在他们所在的外部函数之外被调用时，就会形成闭包。
          作用：可以读取函数内部的变量，并让这些变量的值始终保存在内存中，延长变量的生命周期
          注意点：由于闭包会使得函数中的变量都保存在内存中，内存消耗很大，所以不能滥用闭包，
          否则会造成网页的性能问题。在退出函数之前，将不使用的局部变量全部删除
        </div>
      <li>18.前端性能优化</li>
      <li>19.npm run dev 时做了什么</li>
        <div>
          1.首先会去项目中的 package.json 文件中找 script 对应的 dev，然后
          执行 dev 的命令
          2.为什么不直接执行 dev 的命令呢？因为这条指令不存在操作系统中，直接执行
          会报错。
          3.那为什么执行 dev 不报错呢？npm install 安装依赖时，会在 node_modules/.bin
          目录中创建好可执行脚本；.bin 目录不是任何一个 npm 包，目录下的文件表示一个个软链接，
          所以当执行 npm run dev 时执行其对应命令就会到 .bin 目录下找到对应脚本来执行。
          4.软链是怎么来的呢？npm install 时，npm 就帮我们把这种软链接配置好了，其实这种软链接
          就相当于一种映射，执行 package.json 命令时，就到 .bin 找映射文件，然后执行对应脚本。
        </div>
      <li>20.cookie、sessionStorage、localStorage区别</li>
        <div>
          共同点：都存储在浏览器本地
          不同点：
            1.cookie 是由服务端写入，而 sessionStorage 和 localStorage 都是由客户端写入
            2.cookie 的生命周期在服务端写入的时候就设置好了；localStorage 除非手动清除，否则一直存在；sessionStorage
            在页面关闭就会自动清除
            3.cookie 的存储空间只有 4KB，localStorage 和 sessionStorage 大概 5MB
            4.cookie 一般用于存储登录验证信息；localStorage 用于存储不易变动的信息，减轻服务端压力；sessionStorage 可以
            检测用户是否刷新进入页面
        </div>
      <li>21.commonJS和ESModule区别</li>
        <div>
          1.commonJS是同步加载模块，ESM是异步加载模块
          2.commonJS输出的是一个值拷贝，即模块内部变化不会影响外部，ESM输出的是只读值引用
          3.commonJS是运行时加载，ESM是编译时输出接口
            commonJS加载的是一个对象，即module.export属性，该对象只有在脚本运行完才会生成
            ESM不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成
        </div>
      <li>22.为什么虚拟Dom可以提高性能</li>
        <div>
          虚拟dom相当于在js和真实dom之间加了一个缓存，利用dom diff 算法避免了没有必要的dom操作，从而提高性能
        </div>
      <li>23.Promise 是什么以及常用的方法</li>
        <div>
          Promise 是用来创建promise对象的构造函数，一个promise对象用来表示一个异步操作的最终状态，以及该异步操作的结果值，
          promise对象是一个代理对象，代理一个值，被代理的值在promise对象创建时是未知的，它允许你为异步操作的成功和失败分别
          绑定相应的处理回调函数，让异步方法可以像同步方法那样被返回。
          常用方法：
          1.finally 无论成功失败都会执行的回调
          2.all 接收一个promise数组，所有promise都成功才会执行成功回调，有一个失败就抛出第一个错误信息
          3.any 接收promise数组，有一个执行通过，则认为成功，否则失败
          4.race 接收promise数组，第一个执行完毕的是通过则认为成功，否则失败
        </div>
    </ul>
  </div>
</body>
</html>